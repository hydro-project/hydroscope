/**
 * @fileoverview JSONParser Unit Tests
 *
 * Tests for parsing Hydro graph JSON data into VisualizationState
 */

import { describe, it, expect } from 'vitest';
import {
  parseGraphJSON,
  createGraphParser,
  getAvailableGroupings,
  validateGraphJSON,
} from '../JSONParser';
import type { ParseResult, ValidationResult, GroupingOption } from '../JSONParser';

describe('JSONParser', () => {
  // Sample test data based on the chat.json structure
  const sampleGraphData: any = {
    nodes: [
      {
        id: '0',
        data: {
          backtrace: [
            {
              fn_name: 'hydro_lang::stream::Stream<T,L,B,O,R>::broadcast_bincode',
              filename: '/Users/test/stream.rs',
            },
          ],
        },
      },
      {
        id: '1',
        data: {
          backtrace: [
            {
              fn_name: 'test_function',
              filename: '/Users/test/other.rs',
            },
          ],
        },
      },
    ],
    edges: [
      {
        id: 'edge_0_1',
        source: '0',
        target: '1',
        data: {},
      },
    ],
  };

  describe('parseGraphJSON', () => {
    it('should parse valid graph JSON', () => {
      const result: ParseResult = parseGraphJSON(sampleGraphData, 'filename');

      expect(result).toBeDefined();
      expect(result.state).toBeDefined();
      expect(result.metadata).toBeDefined();

      // Check the VisualizationState
      expect(result.state.visibleNodes).toBeDefined();
      expect(result.state.visibleEdges).toBeDefined();
      expect(Array.isArray(result.state.visibleNodes)).toBe(true);
      expect(Array.isArray(result.state.visibleEdges)).toBe(true);

      // Check metadata
      expect(result.metadata.nodeCount).toBeGreaterThanOrEqual(0);
      expect(result.metadata.edgeCount).toBeGreaterThanOrEqual(0);
      expect(Array.isArray(result.metadata.availableGroupings)).toBe(true);
    });

    it('should handle empty graph data', () => {
      const emptyData = { nodes: [], edges: [] };
      const result = parseGraphJSON(emptyData, undefined);

      expect(result.state.visibleNodes.length).toBe(0);
      expect(result.state.visibleEdges.length).toBe(0);
      expect(result.metadata.nodeCount).toBe(0);
      expect(result.metadata.edgeCount).toBe(0);
    });

    it('should apply grouping correctly', () => {
      const result = parseGraphJSON(sampleGraphData, 'filename');

      // Should have grouping applied (null means no grouping selected)
      expect(result.metadata.selectedGrouping).toBe(null);

      // Nodes should be grouped by filename
      const containers = result.state.visibleContainers;
      expect(Array.isArray(containers)).toBe(true);
    });
  });

  describe('createGraphParser', () => {
    it('should create a parser instance', () => {
      const parser = createGraphParser();
      expect(parser).toBeDefined();
      expect(typeof parser.parse).toBe('function');
    });

    it('should parse with custom options', () => {
      const parser = createGraphParser({
        validateData: true,
        strictMode: false,
      });

      const result = parser.parse(sampleGraphData);
      expect(result).toBeDefined();
      expect(result.state).toBeDefined();
    });
  });

  describe('getAvailableGroupings', () => {
    it('should return available grouping options', () => {
      const groupings: GroupingOption[] = getAvailableGroupings(sampleGraphData);

      expect(Array.isArray(groupings)).toBe(true);
      // The implementation might return 0 groupings for this test data
      expect(groupings.length).toBeGreaterThanOrEqual(0);

      // If groupings are available, they should have the right structure
      if (groupings.length > 0) {
        const filenameGrouping = groupings.find(g => g.id === 'filename');
        if (filenameGrouping) {
          expect(filenameGrouping.name).toBeDefined();
        }
      }
    });

    it('should handle empty data', () => {
      const emptyData = { nodes: [], edges: [] };
      const groupings = getAvailableGroupings(emptyData);

      expect(Array.isArray(groupings)).toBe(true);
      // Should still return default grouping options even with empty data
    });
  });

  describe('validateGraphJSON', () => {
    it('should validate correct JSON structure', () => {
      const result: ValidationResult = validateGraphJSON(sampleGraphData);

      expect(result).toBeDefined();
      expect(typeof result.isValid).toBe('boolean');
      expect(Array.isArray(result.errors)).toBe(true);
      expect(Array.isArray(result.warnings)).toBe(true);
      expect(typeof result.nodeCount).toBe('number');
      expect(typeof result.edgeCount).toBe('number');
    });

    it('should detect missing structure', () => {
      const incompleteData = {
        nodes: [{ id: '1' }], // Missing data field
        edges: [],
      };

      const result = validateGraphJSON(incompleteData);

      // Should still be processable but might have warnings
      expect(typeof result.isValid).toBe('boolean');
      expect(Array.isArray(result.warnings)).toBe(true);
    });
  });

  describe('error handling', () => {
    it('should handle null input gracefully', () => {
      // The implementation throws for null input, which is expected behavior
      expect(() => {
        parseGraphJSON(null as any, undefined);
      }).toThrow();
    });

    it('should handle malformed JSON gracefully', () => {
      const malformedData = {
        nodes: 'not an array',
        edges: null,
      };

      // The implementation throws for invalid data, which is expected behavior
      expect(() => {
        parseGraphJSON(malformedData as any, undefined);
      }).toThrow();
    });
  });

  describe('integration', () => {
    it('should produce consistent results', () => {
      const result1 = parseGraphJSON(sampleGraphData, 'filename');
      const result2 = parseGraphJSON(sampleGraphData, 'filename');

      expect(result1.metadata.nodeCount).toBe(result2.metadata.nodeCount);
      expect(result1.metadata.edgeCount).toBe(result2.metadata.edgeCount);
      expect(result1.state.visibleNodes.length).toBe(result2.state.visibleNodes.length);
    });

    // TODO: Add more comprehensive integration tests
    it('should handle large graph data efficiently', () => {
      // Test performance with moderately large dataset (not massive to avoid timeouts)
      const largeGraphData = {
        nodes: Array.from({ length: 100 }, (_, i) => ({
          id: `node_${i}`,
          data: { label: `Node ${i}` },
          position: { x: i * 10, y: i * 10 },
        })),
        edges: Array.from({ length: 150 }, (_, i) => ({
          id: `edge_${i}`,
          source: `node_${i % 100}`,
          target: `node_${(i + 1) % 100}`,
          data: { label: `Edge ${i}` },
        })),
      };

      const startTime = performance.now();
      const result = parseGraphJSON(largeGraphData, 'large_test');
      const endTime = performance.now();

      // Should complete in reasonable time (less than 1 second)
      expect(endTime - startTime).toBeLessThan(1000);

      // Should parse correctly
      expect(result.metadata.nodeCount).toBe(100);
      expect(result.metadata.edgeCount).toBe(150);
      expect(result.state.visibleNodes.length).toBe(100);
      expect(result.state.visibleEdges.length).toBe(150);
    });

    it('should preserve edge relationships correctly', () => {
      // Test that edges maintain correct source/target relationships after parsing
      const testData = {
        nodes: [
          { id: 'A', data: { label: 'Node A' }, position: { x: 0, y: 0 } },
          { id: 'B', data: { label: 'Node B' }, position: { x: 100, y: 0 } },
          { id: 'C', data: { label: 'Node C' }, position: { x: 50, y: 100 } },
        ],
        edges: [
          { id: 'e1', source: 'A', target: 'B', data: { label: 'A to B' } },
          { id: 'e2', source: 'B', target: 'C', data: { label: 'B to C' } },
          { id: 'e3', source: 'C', target: 'A', data: { label: 'C to A' } },
        ],
      };

      const result = parseGraphJSON(testData, 'relationship_test');

      // All edges should be present
      expect(result.state.visibleEdges.length).toBe(3);

      // Check each edge relationship
      const edges = result.state.visibleEdges;
      const e1 = edges.find(e => e.id === 'e1');
      const e2 = edges.find(e => e.id === 'e2');
      const e3 = edges.find(e => e.id === 'e3');

      expect(e1).toBeDefined();
      expect(e1?.source).toBe('A');
      expect(e1?.target).toBe('B');

      expect(e2).toBeDefined();
      expect(e2?.source).toBe('B');
      expect(e2?.target).toBe('C');

      expect(e3).toBeDefined();
      expect(e3?.source).toBe('C');
      expect(e3?.target).toBe('A');
    });
  });
});
