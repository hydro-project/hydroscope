/**
 * StyleTuner - Standalone panel component for real-time style configuration
 * 
 * Extracted from HydroscopeEnhanced to provide:
 * - Layout algorithm selection (layered, mrtree, force, stress, radial)
 * - Color palette selection (Set2, Set3, Pastel1, Dark2)
 * - Edge style configuration (bezier, straight, smoothstep)
 * - Style configuration controls for edges, nodes, containers
 * - Reset to defaults functionality
 * - Real-time preview with local state synchronization
 * - Operation queuing to prevent timing conflicts
 * - Settings persistence to localStorage with error handling
 * - Integration with v6 architecture without timing bugs
 * 
 * ## V6 Architecture Integration
 * 
 * This component integrates with the v6 architecture through:
 * - **VisualizationState**: Access to current graph state for style application
 * - **AsyncCoordinator**: Proper operation sequencing to prevent race conditions
 * - **Error Handling**: Graceful degradation when v6 components are unavailable
 * - **Local State Management**: Immediate UI updates with eventual consistency
 * 
 * ## Usage Example
 * 
 * ```tsx
 * import { StyleTuner } from '@hydro-project/hydroscope';
 * 
 * function MyComponent() {
 *   const [stylePanelOpen, setStylePanelOpen] = useState(true);
 *   const [styleConfig, setStyleConfig] = useState({
 *     edgeStyle: 'bezier',
 *     edgeWidth: 2,
 *     nodePadding: 8
 *   });
 *   
 *   return (
 *     <StyleTuner
 *       value={styleConfig}
 *       onChange={setStyleConfig}
 *       open={stylePanelOpen}
 *       onOpenChange={setStylePanelOpen}
 *       onLayoutChange={(layout) => {
 *         console.log(`Layout changed to: ${layout}`);
 *       }}
 *       onError={(error) => {
 *         console.error('StyleTuner error:', error);
 *       }}
 *     />
 *   );
 * }
 * ```
 * 
 * ## Migration from Embedded Implementation
 * 
 * If migrating from HydroscopeEnhanced's embedded StyleTuner:
 * 1. Replace embedded usage with standalone StyleTuner component
 * 2. Manage style configuration state in parent component
 * 3. Handle panel visibility state in parent component
 * 4. Update callback signatures to match new interface
 * 5. Remove ReactFlow controls scale configuration (no longer supported)
 * 
 * @since 1.0.0-alpha.7
 */

import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
import { COLOR_PALETTES } from "../../shared/config.js";
import { VisualizationState } from "../../core/VisualizationState.js";
import { AsyncCoordinator } from "../../core/AsyncCoordinator.js";

// ============================================================================
// Helper Components
// ============================================================================

interface CollapsibleSectionProps {
  title: string;
  collapsed: boolean;
  onToggle: () => void;
  children: React.ReactNode;
}

const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({
  title,
  collapsed,
  onToggle,
  children
}) => {
  return (
    <div style={{
      border: '1px solid #e0e0e0',
      borderRadius: '6px',
      overflow: 'hidden',
      backgroundColor: 'white'
    }}>
      <button
        onClick={onToggle}
        style={{
          width: '100%',
          padding: '12px 16px',
          backgroundColor: collapsed ? '#f8f9fa' : '#e9ecef',
          border: 'none',
          borderBottom: collapsed ? 'none' : '1px solid #e0e0e0',
          cursor: 'pointer',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          fontSize: '14px',
          fontWeight: '600',
          color: '#2c3e50',
          transition: 'background-color 0.2s ease',
        }}
        onMouseEnter={(e) => {
          e.currentTarget.style.backgroundColor = collapsed ? '#f0f0f0' : '#dee2e6';
        }}
        onMouseLeave={(e) => {
          e.currentTarget.style.backgroundColor = collapsed ? '#f8f9fa' : '#e9ecef';
        }}
      >
        <span>{title}</span>
        <span style={{
          transform: collapsed ? 'rotate(0deg)' : 'rotate(180deg)',
          transition: 'transform 0.2s ease',
          fontSize: '12px'
        }}>
          â–¼
        </span>
      </button>
      
      {!collapsed && (
        <div style={{
          padding: '16px',
          animation: 'slideDown 0.2s ease-out',
        }}>
          {children}
        </div>
      )}
    </div>
  );
};

// ============================================================================
// TypeScript Interfaces
// ============================================================================

/**
 * Props interface for the StyleTuner component
 * 
 * @interface StyleTunerProps
 */
export interface StyleTunerProps {
  /** 
   * Current style configuration
   * 
   * Complete style configuration object containing all visual styling
   * properties for edges, nodes, and containers. Changes to this object
   * trigger immediate UI updates with local state management.
   * 
   * @required
   */
  value: StyleConfig;
  
  /** 
   * Callback when style configuration changes
   * 
   * Called whenever user modifies any style property through the UI controls.
   * Parent component should update the value prop to reflect changes.
   * 
   * @param config - Updated style configuration
   * @required
   */
  onChange: (config: StyleConfig) => void;
  
  /** 
   * Current color palette
   * 
   * Name of the currently selected color palette (Set2, Set3, Pastel1, Dark2).
   * Used to determine which palette is highlighted in the selection UI.
   * 
   * @optional
   */
  colorPalette?: string;
  
  /** 
   * Callback when color palette changes
   * 
   * Called when user selects a different color palette from the available options.
   * Parent component should update visualization colors accordingly.
   * 
   * @param palette - Name of the selected color palette
   * @optional
   */
  onPaletteChange?: (palette: string) => void;
  
  /** 
   * Current layout algorithm
   * 
   * Name of the currently active layout algorithm (layered, mrtree, force, stress, radial).
   * Used to highlight the active algorithm in the selection UI.
   * 
   * @optional
   */
  currentLayout?: string;
  
  /** 
   * Callback when layout algorithm changes
   * 
   * Called when user selects a different layout algorithm. Parent component
   * should trigger a relayout operation with the new algorithm.
   * 
   * @param layout - Name of the selected layout algorithm
   * @optional
   */
  onLayoutChange?: (layout: string) => void;
  
  /** 
   * V6 VisualizationState for architecture integration
   * 
   * Provides access to current graph state for style application and validation.
   * Used to ensure style changes are compatible with current graph structure.
   * 
   * @optional
   */
  visualizationState?: VisualizationState | null;
  
  /** 
   * V6 AsyncCoordinator for operation sequencing
   * 
   * Used to coordinate style application operations with other components
   * and prevent timing conflicts or race conditions.
   * 
   * @optional
   */
  asyncCoordinator?: AsyncCoordinator | null;
  
  /** 
   * Callback for reset to defaults
   * 
   * Called when user clicks the "Reset to Defaults" button.
   * Parent component should reset all style-related settings to defaults.
   * 
   * @optional
   */
  onResetToDefaults?: () => void;
  
  /** 
   * Panel visibility state
   * 
   * Controls whether the StyleTuner panel is currently visible/open.
   * When false, panel slides out of view.
   * 
   * @required
   */
  open: boolean;
  
  /** 
   * Callback to change panel visibility
   * 
   * Called when user clicks the panel toggle button or when panel
   * needs to be programmatically shown/hidden.
   * 
   * @param open - New visibility state
   * @required
   */
  onOpenChange: (open: boolean) => void;
  
  /** 
   * Error handling callback
   * 
   * Called when StyleTuner encounters errors during style application
   * or other operations. Allows parent component to handle errors gracefully.
   * 
   * @param error - The error that occurred
   * @optional
   */
  onError?: (error: Error) => void;
  
  /** 
   * Optional custom styling
   * 
   * CSS class name to apply to the StyleTuner root element
   * for custom styling.
   * 
   * @optional
   */
  className?: string;
  
  /** 
   * Optional style overrides
   * 
   * Inline styles to apply to the StyleTuner root element.
   * Use sparingly - prefer className for styling.
   * 
   * @optional
   */
  style?: React.CSSProperties;
}

/**
 * Complete style configuration for graph visualization
 * 
 * Contains all visual styling properties that can be configured through
 * the StyleTuner interface. All properties are optional to allow partial
 * configuration and gradual style application.
 * 
 * @interface StyleConfig
 */
export interface StyleConfig {
  // Edge Styles
  /** Edge curve type - affects how edges are drawn between nodes */
  edgeStyle?: 'bezier' | 'straight' | 'smoothstep';
  /** Edge color (hex, rgb, or named color) */
  edgeColor?: string;
  /** Edge width in pixels */
  edgeWidth?: number;
  /** Whether edges should be drawn with dashed lines */
  edgeDashed?: boolean;
  /** Whether edges should have animated flow indicators */
  edgeAnimated?: boolean;
  
  // Node Styles
  /** Background color for node content area */
  nodeBackgroundColor?: string;
  /** Border color for node outline */
  nodeBorderColor?: string;
  /** Border width in pixels */
  nodeBorderWidth?: number;
  /** Border radius for rounded corners */
  nodeBorderRadius?: number;
  /** Font size for node labels */
  nodeFontSize?: number;
  /** Font family for node labels */
  nodeFontFamily?: string;
  /** Font weight for node labels */
  nodeFontWeight?: 'normal' | 'bold';
  /** Internal padding within nodes */
  nodePadding?: number;
  
  // Container Styles
  /** Background color for container areas */
  containerBackgroundColor?: string;
  /** Border color for container outlines */
  containerBorderColor?: string;
  /** Border width for containers in pixels */
  containerBorderWidth?: number;
  /** Border radius for container corners */
  containerBorderRadius?: number;
  /** Drop shadow intensity for containers */
  containerShadow?: 'none' | 'light' | 'medium' | 'heavy';
  /** Container background opacity (0-1) */
  containerOpacity?: number;
}

/**
 * Layout algorithm configuration
 * 
 * Defines available layout algorithms that can be selected through
 * the StyleTuner interface.
 * 
 * @interface LayoutAlgorithm
 */
export interface LayoutAlgorithm {
  /** Unique identifier for this algorithm */
  id: string;
  /** Human-readable name displayed in UI */
  name: string;
  /** Description explaining the algorithm's behavior */
  description: string;
  /** The actual ELK algorithm identifier used for layout */
  elkId: string;
}

/**
 * Color palette configuration
 * 
 * Defines available color palettes that can be selected through
 * the StyleTuner interface.
 * 
 * @interface ColorPaletteOption
 */
export interface ColorPaletteOption {
  /** Unique identifier for this palette */
  id: string;
  /** Human-readable name displayed in UI */
  name: string;
  /** Description explaining the palette's characteristics */
  description: string;
  /** Array of colors in this palette with optional metadata */
  colors: Array<{ 
    /** Primary color value */
    primary: string; 
    /** Optional secondary/accent color */
    secondary?: string; 
    /** Optional human-readable color name */
    name?: string 
  }>;
}

// ============================================================================
// Internal State Interfaces
// ============================================================================

interface StyleTunerState {
  local: StyleConfig; // Local state for immediate UI updates
  layoutCollapsed: boolean;
  paletteCollapsed: boolean;
  edgeStyleCollapsed: boolean;
  nodeStyleCollapsed: boolean;
  containerStyleCollapsed: boolean;
  btnHover: boolean; // Button hover state
  btnFocus: boolean; // Button focus state
  settingsStatus: 'idle' | 'saving' | 'saved' | 'error';
}

interface StyleTunerSettings {
  layoutCollapsed: boolean;
  paletteCollapsed: boolean;
  edgeStyleCollapsed: boolean;
  nodeStyleCollapsed: boolean;
  containerStyleCollapsed: boolean;
  colorPalette?: string;
  layoutAlgorithm?: string;
  styleConfig: StyleConfig;
}

// ============================================================================
// Constants and Defaults
// ============================================================================

const LAYOUT_ALGORITHMS: LayoutAlgorithm[] = [
  {
    id: 'layered',
    name: 'Layered (Hierarchical)',
    description: 'Hierarchical layout with clear layers',
    elkId: 'layered'
  },
  {
    id: 'mrtree',
    name: 'Tree (Multi-Root)',
    description: 'Tree layout supporting multiple roots',
    elkId: 'mrtree'
  },
  {
    id: 'force',
    name: 'Force-Directed',
    description: 'Physics-based force simulation',
    elkId: 'force'
  },
  {
    id: 'stress',
    name: 'Stress Minimization',
    description: 'Stress-based layout optimization',
    elkId: 'stress'
  },
  {
    id: 'radial',
    name: 'Radial',
    description: 'Radial layout from center outward',
    elkId: 'radial'
  }
];

const COLOR_PALETTE_OPTIONS: ColorPaletteOption[] = [
  {
    id: 'Set2',
    name: 'Set2 (Balanced)',
    description: 'Balanced colors with good contrast',
    colors: COLOR_PALETTES.Set2
  },
  {
    id: 'Set3',
    name: 'Set3 (Light)',
    description: 'Light, pastel colors',
    colors: COLOR_PALETTES.Set3
  },
  {
    id: 'Pastel1',
    name: 'Pastel1 (Soft)',
    description: 'Soft, muted colors',
    colors: COLOR_PALETTES.Pastel1
  },
  {
    id: 'Dark2',
    name: 'Dark2 (Bold)',
    description: 'Bold, high-contrast colors',
    colors: COLOR_PALETTES.Dark2
  }
];

const DEFAULT_STYLE_CONFIG: StyleConfig = {
  // Edge Styles
  edgeStyle: 'bezier',
  edgeColor: '#1976d2',
  edgeWidth: 2,
  edgeDashed: false,
  edgeAnimated: false,
  
  // Node Styles
  nodeBackgroundColor: '#ffffff',
  nodeBorderColor: '#cccccc',
  nodeBorderWidth: 1,
  nodeBorderRadius: 4,
  nodeFontSize: 12,
  nodeFontFamily: 'Arial, sans-serif',
  nodeFontWeight: 'normal',
  nodePadding: 8,
  
  // Container Styles
  containerBackgroundColor: '#f8f9fa',
  containerBorderColor: '#dee2e6',
  containerBorderWidth: 2,
  containerBorderRadius: 8,
  containerShadow: 'light',
  containerOpacity: 0.9
};

// ============================================================================
// Settings Persistence Utilities
// ============================================================================

const STORAGE_KEY = 'hydroscope-styletuner-settings';

const saveSettings = (settings: StyleTunerSettings): void => {
  try {
    // Validate settings before saving
    const validatedSettings = validateSettings(settings);
    const settingsJson = JSON.stringify(validatedSettings);
    
    // Check if localStorage is available
    if (typeof Storage === 'undefined') {
      console.warn('StyleTuner: localStorage not available, settings not saved');
      return;
    }
    
    localStorage.setItem(STORAGE_KEY, settingsJson);
    console.log('StyleTuner: Settings saved to localStorage', {
      size: settingsJson.length,
      timestamp: new Date().toISOString()
    });
    
    // Verify the save was successful
    const verification = localStorage.getItem(STORAGE_KEY);
    if (!verification || verification !== settingsJson) {
      console.warn('StyleTuner: Settings save verification failed');
    }
  } catch (error) {
    console.error('StyleTuner: Failed to save settings to localStorage:', error);
    
    // Detailed error handling
    if (error instanceof Error) {
      if (error.name === 'QuotaExceededError') {
        console.warn('StyleTuner: localStorage quota exceeded, attempting cleanup');
        try {
          // Try to clear old data and save again
          const keys = Object.keys(localStorage);
          const hydroscopeKeys = keys.filter(key => key.startsWith('hydroscope-'));
          if (hydroscopeKeys.length > 1) {
            // Remove oldest hydroscope settings
            hydroscopeKeys.slice(0, -1).forEach(key => {
              try {
                localStorage.removeItem(key);
              } catch (cleanupError) {
                console.error('StyleTuner: Error during cleanup:', cleanupError);
              }
            });
            // Retry save
            localStorage.setItem(STORAGE_KEY, JSON.stringify(validateSettings(settings)));
            console.log('StyleTuner: Settings saved after cleanup');
          }
        } catch (cleanupError) {
          console.error('StyleTuner: Cleanup and retry failed:', cleanupError);
        }
      } else if (error.name === 'SecurityError') {
        console.warn('StyleTuner: localStorage access denied (private browsing?), settings not saved');
      } else {
        console.error('StyleTuner: Unexpected error saving settings:', error.message);
      }
    }
  }
};

const validateSettings = (settings: StyleTunerSettings): StyleTunerSettings => {
  const defaultSettings = getDefaultSettings();
  
  return {
    layoutCollapsed: typeof settings.layoutCollapsed === 'boolean' ? settings.layoutCollapsed : defaultSettings.layoutCollapsed,
    paletteCollapsed: typeof settings.paletteCollapsed === 'boolean' ? settings.paletteCollapsed : defaultSettings.paletteCollapsed,
    edgeStyleCollapsed: typeof settings.edgeStyleCollapsed === 'boolean' ? settings.edgeStyleCollapsed : defaultSettings.edgeStyleCollapsed,
    nodeStyleCollapsed: typeof settings.nodeStyleCollapsed === 'boolean' ? settings.nodeStyleCollapsed : defaultSettings.nodeStyleCollapsed,
    containerStyleCollapsed: typeof settings.containerStyleCollapsed === 'boolean' ? settings.containerStyleCollapsed : defaultSettings.containerStyleCollapsed,
    colorPalette: typeof settings.colorPalette === 'string' && COLOR_PALETTE_OPTIONS.some(p => p.id === settings.colorPalette) 
      ? settings.colorPalette 
      : defaultSettings.colorPalette,
    layoutAlgorithm: typeof settings.layoutAlgorithm === 'string' && LAYOUT_ALGORITHMS.some(a => a.id === settings.layoutAlgorithm)
      ? settings.layoutAlgorithm
      : defaultSettings.layoutAlgorithm,
    styleConfig: validateStyleConfig(settings.styleConfig || {})
  };
};

const validateStyleConfig = (config: Partial<StyleConfig>): StyleConfig => {
  const defaults = DEFAULT_STYLE_CONFIG;
  
  return {
    // Edge Styles
    edgeStyle: ['bezier', 'straight', 'smoothstep'].includes(config.edgeStyle || '') 
      ? config.edgeStyle as 'bezier' | 'straight' | 'smoothstep'
      : defaults.edgeStyle,
    edgeColor: typeof config.edgeColor === 'string' && /^#[0-9A-Fa-f]{6}$/.test(config.edgeColor)
      ? config.edgeColor
      : defaults.edgeColor,
    edgeWidth: typeof config.edgeWidth === 'number' && config.edgeWidth >= 1 && config.edgeWidth <= 8
      ? config.edgeWidth
      : defaults.edgeWidth,
    edgeDashed: typeof config.edgeDashed === 'boolean' ? config.edgeDashed : defaults.edgeDashed,
    edgeAnimated: typeof config.edgeAnimated === 'boolean' ? config.edgeAnimated : defaults.edgeAnimated,
    
    // Node Styles
    nodeBackgroundColor: typeof config.nodeBackgroundColor === 'string' && /^#[0-9A-Fa-f]{6}$/.test(config.nodeBackgroundColor)
      ? config.nodeBackgroundColor
      : defaults.nodeBackgroundColor,
    nodeBorderColor: typeof config.nodeBorderColor === 'string' && /^#[0-9A-Fa-f]{6}$/.test(config.nodeBorderColor)
      ? config.nodeBorderColor
      : defaults.nodeBorderColor,
    nodeBorderWidth: typeof config.nodeBorderWidth === 'number' && config.nodeBorderWidth >= 0 && config.nodeBorderWidth <= 5
      ? config.nodeBorderWidth
      : defaults.nodeBorderWidth,
    nodeBorderRadius: typeof config.nodeBorderRadius === 'number' && config.nodeBorderRadius >= 0 && config.nodeBorderRadius <= 20
      ? config.nodeBorderRadius
      : defaults.nodeBorderRadius,
    nodeFontSize: typeof config.nodeFontSize === 'number' && config.nodeFontSize >= 8 && config.nodeFontSize <= 20
      ? config.nodeFontSize
      : defaults.nodeFontSize,
    nodeFontFamily: typeof config.nodeFontFamily === 'string' ? config.nodeFontFamily : defaults.nodeFontFamily,
    nodeFontWeight: ['normal', 'bold'].includes(config.nodeFontWeight || '')
      ? config.nodeFontWeight as 'normal' | 'bold'
      : defaults.nodeFontWeight,
    nodePadding: typeof config.nodePadding === 'number' && config.nodePadding >= 4 && config.nodePadding <= 20
      ? config.nodePadding
      : defaults.nodePadding,
    
    // Container Styles
    containerBackgroundColor: typeof config.containerBackgroundColor === 'string' && /^#[0-9A-Fa-f]{6}$/.test(config.containerBackgroundColor)
      ? config.containerBackgroundColor
      : defaults.containerBackgroundColor,
    containerBorderColor: typeof config.containerBorderColor === 'string' && /^#[0-9A-Fa-f]{6}$/.test(config.containerBorderColor)
      ? config.containerBorderColor
      : defaults.containerBorderColor,
    containerBorderWidth: typeof config.containerBorderWidth === 'number' && config.containerBorderWidth >= 0 && config.containerBorderWidth <= 8
      ? config.containerBorderWidth
      : defaults.containerBorderWidth,
    containerBorderRadius: typeof config.containerBorderRadius === 'number' && config.containerBorderRadius >= 0 && config.containerBorderRadius <= 20
      ? config.containerBorderRadius
      : defaults.containerBorderRadius,
    containerShadow: ['none', 'light', 'medium', 'heavy'].includes(config.containerShadow || '')
      ? config.containerShadow as 'none' | 'light' | 'medium' | 'heavy'
      : defaults.containerShadow,
    containerOpacity: typeof config.containerOpacity === 'number' && config.containerOpacity >= 0.1 && config.containerOpacity <= 1
      ? config.containerOpacity
      : defaults.containerOpacity,
  };
};

const loadSettings = (): StyleTunerSettings | null => {
  try {
    // Check if localStorage is available
    if (typeof Storage === 'undefined') {
      console.warn('StyleTuner: localStorage not available, using defaults');
      return null;
    }
    
    const stored = localStorage.getItem(STORAGE_KEY);
    if (!stored) {
      console.log('StyleTuner: No saved settings found, using defaults');
      return null;
    }

    const parsed = JSON.parse(stored);
    console.log('StyleTuner: Settings loaded from localStorage', {
      size: stored.length,
      timestamp: new Date().toISOString()
    });

    // Comprehensive validation of loaded settings
    const validatedSettings = validateSettings(parsed);
    
    // Check if validation changed anything (indicates corrupted data)
    const originalJson = JSON.stringify(parsed);
    const validatedJson = JSON.stringify(validatedSettings);
    if (originalJson !== validatedJson) {
      console.warn('StyleTuner: Settings were corrected during validation, saving corrected version');
      // Save the corrected settings back to localStorage
      try {
        localStorage.setItem(STORAGE_KEY, validatedJson);
      } catch (saveError) {
        console.error('StyleTuner: Failed to save corrected settings:', saveError);
      }
    }

    return validatedSettings;
  } catch (error) {
    console.error('StyleTuner: Failed to load settings from localStorage:', error);
    
    // Detailed error handling
    if (error instanceof Error) {
      if (error.name === 'SyntaxError') {
        console.warn('StyleTuner: Settings data corrupted, clearing and using defaults');
        try {
          localStorage.removeItem(STORAGE_KEY);
        } catch (clearError) {
          console.error('StyleTuner: Failed to clear corrupted settings:', clearError);
        }
      } else if (error.name === 'SecurityError') {
        console.warn('StyleTuner: localStorage access denied (private browsing?), using defaults');
      } else {
        console.error('StyleTuner: Unexpected error loading settings:', error.message);
      }
    }
    
    console.warn('StyleTuner: Using default settings due to load error');
    return null;
  }
};

const getDefaultSettings = (): StyleTunerSettings => ({
  layoutCollapsed: false,
  paletteCollapsed: false,
  edgeStyleCollapsed: false,
  nodeStyleCollapsed: false,
  containerStyleCollapsed: false,
  styleConfig: DEFAULT_STYLE_CONFIG
});

// ============================================================================
// StyleTuner Component
// ============================================================================

export const StyleTuner: React.FC<StyleTunerProps> = ({
  value,
  onChange,
  colorPalette = 'Set3',
  onPaletteChange,
  currentLayout = 'layered',
  onLayoutChange,
  visualizationState,
  asyncCoordinator,
  onResetToDefaults,
  open,
  onOpenChange,
  onError,
  className,
  style,
}) => {
  // ============================================================================
  // State Management
  // ============================================================================

  // Load initial settings from localStorage
  const [state, setState] = useState<StyleTunerState>(() => {
    const savedSettings = loadSettings() || getDefaultSettings();
    return {
      local: { ...DEFAULT_STYLE_CONFIG, ...value }, // Merge props with defaults
      ...savedSettings,
      btnHover: false,
      btnFocus: false,
      settingsStatus: 'idle',
    };
  });

  // Operation queue to prevent timing conflicts
  const operationQueueRef = useRef<Array<() => Promise<void>>>([]);
  const processingQueueRef = useRef<boolean>(false);

  // ============================================================================
  // Settings Persistence
  // ============================================================================

  // Save settings when collapsible states or configuration changes (debounced)
  useEffect(() => {
    setState(prev => ({ ...prev, settingsStatus: 'saving' }));

    const timeoutId = setTimeout(() => {
      try {
        const settings: StyleTunerSettings = {
          layoutCollapsed: state.layoutCollapsed,
          paletteCollapsed: state.paletteCollapsed,
          edgeStyleCollapsed: state.edgeStyleCollapsed,
          nodeStyleCollapsed: state.nodeStyleCollapsed,
          containerStyleCollapsed: state.containerStyleCollapsed,
          colorPalette,
          layoutAlgorithm: currentLayout,
          styleConfig: state.local
        };
        saveSettings(settings);
        setState(prev => ({ ...prev, settingsStatus: 'saved' }));

        // Clear saved status after 2 seconds
        setTimeout(() => {
          setState(prev => ({ ...prev, settingsStatus: 'idle' }));
        }, 2000);
      } catch (error) {
        console.error('StyleTuner: Error saving settings:', error);
        setState(prev => ({ ...prev, settingsStatus: 'error' }));
        onError?.(error as Error);
      }
    }, 500); // Debounce saves by 500ms

    return () => clearTimeout(timeoutId);
  }, [
    state.layoutCollapsed,
    state.paletteCollapsed,
    state.edgeStyleCollapsed,
    state.nodeStyleCollapsed,
    state.containerStyleCollapsed,
    state.local,
    colorPalette,
    currentLayout,
    onError,
  ]);

  // ============================================================================
  // Operation Queue Management
  // ============================================================================

  const processOperationQueue = useCallback(async () => {
    if (processingQueueRef.current || operationQueueRef.current.length === 0) {
      return;
    }

    processingQueueRef.current = true;

    try {
      while (operationQueueRef.current.length > 0) {
        const operation = operationQueueRef.current.shift();
        if (operation) {
          await operation();
          // Small delay to prevent overwhelming the system
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      }
    } catch (error) {
      console.error('StyleTuner: Error processing operation queue:', error);
      onError?.(error as Error);
    } finally {
      processingQueueRef.current = false;
    }
  }, [onError]);

  const queueOperation = useCallback((operation: () => Promise<void>) => {
    operationQueueRef.current.push(operation);
    processOperationQueue();
  }, [processOperationQueue]);

  // ============================================================================
  // Event Handlers
  // ============================================================================

  const handleSectionToggle = useCallback((section: keyof StyleTunerState) => {
    setState(prev => ({
      ...prev,
      [section]: !prev[section],
    }));
  }, []);

  const handleLocalStyleChange = useCallback((newConfig: Partial<StyleConfig>) => {
    setState(prev => ({
      ...prev,
      local: { ...prev.local, ...newConfig }
    }));

    // Queue the actual change to prevent timing conflicts
    queueOperation(async () => {
      try {
        const updatedConfig = { ...value, ...newConfig };
        
        // V6 Architecture Integration: Log integration status
        if (asyncCoordinator && visualizationState) {
          console.log('StyleTuner: V6 architecture available - style changes will be coordinated');
        } else {
          // Graceful degradation when v6 components are unavailable
          if (!visualizationState) {
            console.warn('StyleTuner: VisualizationState unavailable - style changes may not be fully applied');
          }
          
          if (!asyncCoordinator) {
            console.warn('StyleTuner: AsyncCoordinator unavailable - using fallback style application');
          }
        }
        
        // Always call the callback for parent component coordination
        onChange(updatedConfig);
      } catch (error) {
        console.error('StyleTuner: Error applying style change:', error);
        onError?.(error as Error);
      }
    });
  }, [value, onChange, onError, queueOperation, visualizationState, asyncCoordinator]);

  const handleLayoutChange = useCallback((layoutId: string) => {
    queueOperation(async () => {
      try {
        // V6 Architecture Integration: Log integration status
        if (asyncCoordinator && visualizationState) {
          console.log(`StyleTuner: V6 architecture available - layout change to ${layoutId} will be coordinated`);
        } else {
          // Graceful degradation when v6 components are unavailable
          if (!visualizationState) {
            console.error('StyleTuner: Cannot apply layout change - VisualizationState unavailable');
            onError?.(new Error('VisualizationState is not available for layout changes'));
            return;
          }
          
          if (!asyncCoordinator) {
            console.warn('StyleTuner: AsyncCoordinator unavailable - using fallback layout change');
          }
        }
        
        // Always call the callback for parent component coordination
        onLayoutChange?.(layoutId);
      } catch (error) {
        console.error('StyleTuner: Error changing layout:', error);
        onError?.(error as Error);
      }
    });
  }, [onLayoutChange, onError, queueOperation, visualizationState, asyncCoordinator]);

  const handlePaletteChange = useCallback((paletteId: string) => {
    queueOperation(async () => {
      try {
        // V6 Architecture Integration: Log integration status
        if (asyncCoordinator && visualizationState) {
          console.log(`StyleTuner: V6 architecture available - palette change to ${paletteId} will be coordinated`);
        } else {
          // Graceful degradation when v6 components are unavailable
          if (!visualizationState) {
            console.warn('StyleTuner: VisualizationState unavailable - palette change may not be fully applied');
          }
          
          if (!asyncCoordinator) {
            console.warn('StyleTuner: AsyncCoordinator unavailable - using fallback palette change');
          }
        }
        
        // Always call the callback for parent component coordination
        onPaletteChange?.(paletteId);
      } catch (error) {
        console.error('StyleTuner: Error changing palette:', error);
        onError?.(error as Error);
      }
    });
  }, [onPaletteChange, onError, queueOperation, visualizationState, asyncCoordinator]);

  const handleResetToDefaults = useCallback(() => {
    try {
      const defaultSettings = getDefaultSettings();
      setState(prev => ({
        ...prev,
        ...defaultSettings,
        local: DEFAULT_STYLE_CONFIG,
      }));

      // Clear localStorage with comprehensive error handling
      try {
        localStorage.removeItem(STORAGE_KEY);
        console.log('StyleTuner: Settings reset to defaults and localStorage cleared');
        
        // Verify the removal was successful
        const verification = localStorage.getItem(STORAGE_KEY);
        if (verification !== null) {
          console.warn('StyleTuner: localStorage removal verification failed, item still exists');
        }
      } catch (storageError) {
        console.error('StyleTuner: Failed to clear settings from localStorage:', storageError);
        
        // Try alternative cleanup methods
        try {
          localStorage.setItem(STORAGE_KEY, '');
          localStorage.removeItem(STORAGE_KEY);
          console.log('StyleTuner: Alternative localStorage cleanup successful');
        } catch (altError) {
          console.error('StyleTuner: Alternative localStorage cleanup also failed:', altError);
        }
      }

      // Queue the reset operation with v6 architecture integration
      queueOperation(async () => {
        try {
          // V6 Architecture Integration: Log integration status
          if (asyncCoordinator && visualizationState) {
            console.log('StyleTuner: V6 architecture available - reset will be coordinated');
          } else {
            // Graceful degradation when v6 components are unavailable
            if (!visualizationState) {
              console.warn('StyleTuner: VisualizationState unavailable during reset - some changes may not be applied');
            }
            
            if (!asyncCoordinator) {
              console.warn('StyleTuner: AsyncCoordinator unavailable during reset - using fallback operations');
            }
          }
          
          // Always call the callbacks for parent component coordination
          onChange(DEFAULT_STYLE_CONFIG);
          onPaletteChange?.('Set3');
          onLayoutChange?.('layered');
          onResetToDefaults?.();
          
          console.log('StyleTuner: Reset to defaults completed successfully');
        } catch (error) {
          console.error('StyleTuner: Error resetting to defaults:', error);
          onError?.(error as Error);
        }
      });
    } catch (error) {
      console.error('StyleTuner: Error resetting to defaults:', error);
      onError?.(error as Error);
    }
  }, [onChange, onPaletteChange, onLayoutChange, onResetToDefaults, onError, queueOperation, visualizationState, asyncCoordinator]);

  // ============================================================================
  // Computed Values
  // ============================================================================

  const currentLayoutAlgorithm = useMemo(() => {
    return LAYOUT_ALGORITHMS.find(alg => alg.id === currentLayout) || LAYOUT_ALGORITHMS[0];
  }, [currentLayout]);

  const currentColorPalette = useMemo(() => {
    return COLOR_PALETTE_OPTIONS.find(pal => pal.id === colorPalette) || COLOR_PALETTE_OPTIONS[1]; // Default to Set3
  }, [colorPalette]);

  // ============================================================================
  // Render
  // ============================================================================

  if (!open) {
    return null;
  }

  return (
    <div
      className={`style-tuner ${className || ''}`}
      style={{
        position: 'fixed',
        top: '0',
        left: '0',
        width: '350px',
        height: '100vh',
        backgroundColor: 'white',
        borderRight: '1px solid #e0e0e0',
        boxShadow: '2px 0 8px rgba(0,0,0,0.1)',
        zIndex: 1000,
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
        transform: 'translateX(0)',
        transition: 'transform 0.3s ease-in-out',
        ...style,
      }}
    >
      {/* CSS Animations */}
      <style>{`
        @keyframes slideDown {
          from {
            opacity: 0;
            max-height: 0;
          }
          to {
            opacity: 1;
            max-height: 500px;
          }
        }
        
        .style-tuner-enter {
          transform: translateX(-100%);
        }
        
        .style-tuner-enter-active {
          transform: translateX(0);
          transition: transform 0.3s ease-in-out;
        }
        
        .style-tuner-exit {
          transform: translateX(0);
        }
        
        .style-tuner-exit-active {
          transform: translateX(-100%);
          transition: transform 0.3s ease-in-out;
        }
      `}</style>

      {/* Header */}
      <div style={{
        padding: '16px 20px',
        borderBottom: '1px solid #e0e0e0',
        backgroundColor: '#f8f9fa',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        flexShrink: 0,
        boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
      }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <h3 style={{
            margin: 0,
            fontSize: '16px',
            fontWeight: '600',
            color: '#2c3e50',
          }}>
            Style Tuner
          </h3>
          {state.settingsStatus === 'saving' && (
            <span style={{ fontSize: '10px', color: '#666' }}>ðŸ’¾</span>
          )}
          {state.settingsStatus === 'saved' && (
            <span style={{ fontSize: '10px', color: '#28a745' }}>âœ“</span>
          )}
          {state.settingsStatus === 'error' && (
            <span style={{ fontSize: '10px', color: '#dc3545' }}>âš </span>
          )}
        </div>
        <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
          <button
            onClick={handleResetToDefaults}
            title="Reset to defaults"
            style={{
              padding: '6px 12px',
              backgroundColor: '#6c757d',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '12px',
              fontWeight: '500',
              transition: 'background-color 0.2s ease',
            }}
            onMouseEnter={(e) => {
              setState(prev => ({ ...prev, btnHover: true }));
              e.currentTarget.style.backgroundColor = '#5a6268';
            }}
            onMouseLeave={(e) => {
              setState(prev => ({ ...prev, btnHover: false }));
              e.currentTarget.style.backgroundColor = '#6c757d';
            }}
            onFocus={() => setState(prev => ({ ...prev, btnFocus: true }))}
            onBlur={() => setState(prev => ({ ...prev, btnFocus: false }))}
          >
            Reset
          </button>
          <button
            onClick={() => onOpenChange(false)}
            title="Close panel"
            style={{
              padding: '4px 8px',
              backgroundColor: 'transparent',
              border: '1px solid #ccc',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '14px',
              color: '#666',
              transition: 'all 0.2s ease',
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = '#f0f0f0';
              e.currentTarget.style.borderColor = '#999';
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = 'transparent';
              e.currentTarget.style.borderColor = '#ccc';
            }}
          >
            âœ•
          </button>
        </div>
      </div>

      {/* Content */}
      <div style={{
        flex: 1,
        overflow: 'auto',
        padding: '20px',
        backgroundColor: '#ffffff',
      }}>
        <ErrorBoundary onError={onError}>
          <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>

            {/* V6 Architecture Status */}
            {(!visualizationState || !asyncCoordinator) && (
              <div style={{
                padding: '12px',
                backgroundColor: '#fff3cd',
                border: '1px solid #ffeaa7',
                borderRadius: '4px',
                fontSize: '12px',
                color: '#856404',
              }}>
                <strong>Limited functionality:</strong> {
                  !visualizationState ? 'VisualizationState unavailable' :
                    !asyncCoordinator ? 'AsyncCoordinator unavailable - using fallback operations' :
                      ''
                }
              </div>
            )}
          {/* Layout Algorithm Section */}
          <CollapsibleSection
            title="Layout Algorithm"
            collapsed={state.layoutCollapsed}
            onToggle={() => handleSectionToggle('layoutCollapsed')}
          >
            <div style={{ marginBottom: '12px' }}>
              <label style={{ 
                display: 'block', 
                fontSize: '12px', 
                marginBottom: '4px',
                fontWeight: '500',
                color: '#333'
              }}>
                Algorithm
              </label>
              <select
                value={currentLayout}
                onChange={(e) => handleLayoutChange(e.target.value)}
                style={{
                  width: '100%',
                  padding: '8px 12px',
                  border: '1px solid #ccc',
                  borderRadius: '4px',
                  fontSize: '14px',
                  backgroundColor: 'white',
                  cursor: 'pointer',
                  transition: 'border-color 0.2s ease',
                }}
                onFocus={(e) => {
                  e.currentTarget.style.borderColor = '#007bff';
                  e.currentTarget.style.outline = 'none';
                }}
                onBlur={(e) => {
                  e.currentTarget.style.borderColor = '#ccc';
                }}
              >
                {LAYOUT_ALGORITHMS.map(algorithm => (
                  <option key={algorithm.id} value={algorithm.id}>
                    {algorithm.name}
                  </option>
                ))}
              </select>
              <div style={{
                fontSize: '11px',
                color: '#666',
                marginTop: '4px',
                fontStyle: 'italic'
              }}>
                {currentLayoutAlgorithm.description}
              </div>
            </div>

            {/* Layout Preview */}
            <div style={{
              padding: '8px',
              backgroundColor: '#f8f9fa',
              borderRadius: '4px',
              border: '1px solid #e9ecef',
              marginTop: '8px'
            }}>
              <div style={{
                fontSize: '11px',
                color: '#666',
                marginBottom: '4px',
                fontWeight: '500'
              }}>
                Current Layout: {currentLayoutAlgorithm.name}
              </div>
              <div style={{
                fontSize: '10px',
                color: '#888'
              }}>
                Changes will trigger automatic relayout
              </div>
            </div>
          </CollapsibleSection>

          {/* Color Palette Section */}
          <CollapsibleSection
            title="Color Palette"
            collapsed={state.paletteCollapsed}
            onToggle={() => handleSectionToggle('paletteCollapsed')}
          >
            <div style={{ marginBottom: '12px' }}>
              <label style={{ 
                display: 'block', 
                fontSize: '12px', 
                marginBottom: '8px',
                fontWeight: '500',
                color: '#333'
              }}>
                Palette Selection
              </label>
              
              {/* Palette Options */}
              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                {COLOR_PALETTE_OPTIONS.map(palette => (
                  <div
                    key={palette.id}
                    onClick={() => handlePaletteChange(palette.id)}
                    style={{
                      padding: '8px 12px',
                      border: `2px solid ${colorPalette === palette.id ? '#007bff' : '#e9ecef'}`,
                      borderRadius: '6px',
                      cursor: 'pointer',
                      backgroundColor: colorPalette === palette.id ? '#f8f9ff' : 'white',
                      transition: 'all 0.2s ease',
                    }}
                    onMouseEnter={(e) => {
                      if (colorPalette !== palette.id) {
                        e.currentTarget.style.borderColor = '#ccc';
                        e.currentTarget.style.backgroundColor = '#f8f9fa';
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (colorPalette !== palette.id) {
                        e.currentTarget.style.borderColor = '#e9ecef';
                        e.currentTarget.style.backgroundColor = 'white';
                      }
                    }}
                  >
                    <div style={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      marginBottom: '6px'
                    }}>
                      <span style={{
                        fontSize: '13px',
                        fontWeight: '500',
                        color: colorPalette === palette.id ? '#007bff' : '#333'
                      }}>
                        {palette.name}
                      </span>
                      {colorPalette === palette.id && (
                        <span style={{ fontSize: '12px', color: '#007bff' }}>âœ“</span>
                      )}
                    </div>
                    
                    {/* Color Preview */}
                    <div style={{
                      display: 'flex',
                      gap: '2px',
                      marginBottom: '4px'
                    }}>
                      {palette.colors.slice(0, 6).map((color, index) => (
                        <div
                          key={index}
                          style={{
                            width: '16px',
                            height: '16px',
                            backgroundColor: color.primary,
                            borderRadius: '2px',
                            border: '1px solid rgba(0,0,0,0.1)'
                          }}
                          title={color.name || color.primary}
                        />
                      ))}
                      {palette.colors.length > 6 && (
                        <div style={{
                          width: '16px',
                          height: '16px',
                          backgroundColor: '#f0f0f0',
                          borderRadius: '2px',
                          border: '1px solid rgba(0,0,0,0.1)',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          fontSize: '8px',
                          color: '#666'
                        }}>
                          +{palette.colors.length - 6}
                        </div>
                      )}
                    </div>
                    
                    <div style={{
                      fontSize: '10px',
                      color: '#666',
                      fontStyle: 'italic'
                    }}>
                      {palette.description}
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {/* Current Palette Preview */}
            <div style={{
              padding: '8px',
              backgroundColor: '#f8f9fa',
              borderRadius: '4px',
              border: '1px solid #e9ecef',
              marginTop: '8px'
            }}>
              <div style={{
                fontSize: '11px',
                color: '#666',
                marginBottom: '6px',
                fontWeight: '500'
              }}>
                Active Palette: {currentColorPalette.name}
              </div>
              <div style={{
                display: 'flex',
                gap: '3px',
                flexWrap: 'wrap'
              }}>
                {currentColorPalette.colors.map((color, index) => (
                  <div
                    key={index}
                    style={{
                      width: '20px',
                      height: '20px',
                      backgroundColor: color.primary,
                      borderRadius: '3px',
                      border: '1px solid rgba(0,0,0,0.1)',
                      position: 'relative'
                    }}
                    title={`${color.name || 'Color'}: ${color.primary}`}
                  />
                ))}
              </div>
            </div>
          </CollapsibleSection>

          {/* Edge Style Configuration */}
          <CollapsibleSection
            title="Edge Styles"
            collapsed={state.edgeStyleCollapsed}
            onToggle={() => handleSectionToggle('edgeStyleCollapsed')}
          >
            <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
              {/* Edge Type */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Edge Type
                </label>
                <select
                  value={state.local.edgeStyle || 'bezier'}
                  onChange={(e) => handleLocalStyleChange({ 
                    edgeStyle: e.target.value as 'bezier' | 'straight' | 'smoothstep' 
                  })}
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid #ccc',
                    borderRadius: '4px',
                    fontSize: '14px',
                    backgroundColor: 'white',
                    cursor: 'pointer',
                  }}
                >
                  <option value="bezier">Bezier Curves</option>
                  <option value="straight">Straight Lines</option>
                  <option value="smoothstep">Smooth Steps</option>
                </select>
              </div>

              {/* Edge Color */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Edge Color
                </label>
                <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                  <input
                    type="color"
                    value={state.local.edgeColor || '#1976d2'}
                    onChange={(e) => handleLocalStyleChange({ edgeColor: e.target.value })}
                    style={{
                      width: '40px',
                      height: '32px',
                      border: '1px solid #ccc',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      padding: '0',
                    }}
                  />
                  <input
                    type="text"
                    value={state.local.edgeColor || '#1976d2'}
                    onChange={(e) => handleLocalStyleChange({ edgeColor: e.target.value })}
                    style={{
                      flex: 1,
                      padding: '6px 8px',
                      border: '1px solid #ccc',
                      borderRadius: '4px',
                      fontSize: '12px',
                      fontFamily: 'monospace',
                    }}
                    placeholder="#1976d2"
                  />
                </div>
              </div>

              {/* Edge Width */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Edge Width: {state.local.edgeWidth || 2}px
                </label>
                <input
                  type="range"
                  min="1"
                  max="8"
                  step="0.5"
                  value={state.local.edgeWidth || 2}
                  onChange={(e) => handleLocalStyleChange({ edgeWidth: parseFloat(e.target.value) })}
                  style={{ 
                    width: '100%',
                    cursor: 'pointer',
                  }}
                />
                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  fontSize: '10px',
                  color: '#666',
                  marginTop: '2px'
                }}>
                  <span>1px</span>
                  <span>8px</span>
                </div>
              </div>

              {/* Edge Options */}
              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                <label style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  fontSize: '12px',
                  cursor: 'pointer',
                }}>
                  <input
                    type="checkbox"
                    checked={state.local.edgeDashed || false}
                    onChange={(e) => handleLocalStyleChange({ edgeDashed: e.target.checked })}
                    style={{ cursor: 'pointer' }}
                  />
                  Dashed edges
                </label>
                <label style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  fontSize: '12px',
                  cursor: 'pointer',
                }}>
                  <input
                    type="checkbox"
                    checked={state.local.edgeAnimated || false}
                    onChange={(e) => handleLocalStyleChange({ edgeAnimated: e.target.checked })}
                    style={{ cursor: 'pointer' }}
                  />
                  Animated edges
                </label>
              </div>
            </div>
          </CollapsibleSection>

          {/* Node Style Configuration */}
          <CollapsibleSection
            title="Node Styles"
            collapsed={state.nodeStyleCollapsed}
            onToggle={() => handleSectionToggle('nodeStyleCollapsed')}
          >
            <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
              {/* Node Colors */}
              <div style={{ display: 'flex', gap: '12px' }}>
                <div style={{ flex: 1 }}>
                  <label style={{ 
                    display: 'block', 
                    fontSize: '12px', 
                    marginBottom: '6px',
                    fontWeight: '500',
                    color: '#333'
                  }}>
                    Background
                  </label>
                  <input
                    type="color"
                    value={state.local.nodeBackgroundColor || '#ffffff'}
                    onChange={(e) => handleLocalStyleChange({ nodeBackgroundColor: e.target.value })}
                    style={{
                      width: '100%',
                      height: '32px',
                      border: '1px solid #ccc',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      padding: '0',
                    }}
                  />
                </div>
                <div style={{ flex: 1 }}>
                  <label style={{ 
                    display: 'block', 
                    fontSize: '12px', 
                    marginBottom: '6px',
                    fontWeight: '500',
                    color: '#333'
                  }}>
                    Border
                  </label>
                  <input
                    type="color"
                    value={state.local.nodeBorderColor || '#cccccc'}
                    onChange={(e) => handleLocalStyleChange({ nodeBorderColor: e.target.value })}
                    style={{
                      width: '100%',
                      height: '32px',
                      border: '1px solid #ccc',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      padding: '0',
                    }}
                  />
                </div>
              </div>

              {/* Node Border Width */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Border Width: {state.local.nodeBorderWidth || 1}px
                </label>
                <input
                  type="range"
                  min="0"
                  max="5"
                  step="0.5"
                  value={state.local.nodeBorderWidth || 1}
                  onChange={(e) => handleLocalStyleChange({ nodeBorderWidth: parseFloat(e.target.value) })}
                  style={{ 
                    width: '100%',
                    cursor: 'pointer',
                  }}
                />
              </div>

              {/* Node Border Radius */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Border Radius: {state.local.nodeBorderRadius || 4}px
                </label>
                <input
                  type="range"
                  min="0"
                  max="20"
                  step="1"
                  value={state.local.nodeBorderRadius || 4}
                  onChange={(e) => handleLocalStyleChange({ nodeBorderRadius: parseInt(e.target.value) })}
                  style={{ 
                    width: '100%',
                    cursor: 'pointer',
                  }}
                />
              </div>

              {/* Node Font Size */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Font Size: {state.local.nodeFontSize || 12}px
                </label>
                <input
                  type="range"
                  min="8"
                  max="20"
                  step="1"
                  value={state.local.nodeFontSize || 12}
                  onChange={(e) => handleLocalStyleChange({ nodeFontSize: parseInt(e.target.value) })}
                  style={{ 
                    width: '100%',
                    cursor: 'pointer',
                  }}
                />
              </div>

              {/* Node Padding */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Padding: {state.local.nodePadding || 8}px
                </label>
                <input
                  type="range"
                  min="4"
                  max="20"
                  step="1"
                  value={state.local.nodePadding || 8}
                  onChange={(e) => handleLocalStyleChange({ nodePadding: parseInt(e.target.value) })}
                  style={{ 
                    width: '100%',
                    cursor: 'pointer',
                  }}
                />
              </div>

              {/* Font Weight */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Font Weight
                </label>
                <select
                  value={state.local.nodeFontWeight || 'normal'}
                  onChange={(e) => handleLocalStyleChange({ 
                    nodeFontWeight: e.target.value as 'normal' | 'bold' 
                  })}
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid #ccc',
                    borderRadius: '4px',
                    fontSize: '14px',
                    backgroundColor: 'white',
                    cursor: 'pointer',
                  }}
                >
                  <option value="normal">Normal</option>
                  <option value="bold">Bold</option>
                </select>
              </div>
            </div>
          </CollapsibleSection>

          {/* Container Style Configuration */}
          <CollapsibleSection
            title="Container Styles"
            collapsed={state.containerStyleCollapsed}
            onToggle={() => handleSectionToggle('containerStyleCollapsed')}
          >
            <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
              {/* Container Colors */}
              <div style={{ display: 'flex', gap: '12px' }}>
                <div style={{ flex: 1 }}>
                  <label style={{ 
                    display: 'block', 
                    fontSize: '12px', 
                    marginBottom: '6px',
                    fontWeight: '500',
                    color: '#333'
                  }}>
                    Background
                  </label>
                  <input
                    type="color"
                    value={state.local.containerBackgroundColor || '#f8f9fa'}
                    onChange={(e) => handleLocalStyleChange({ containerBackgroundColor: e.target.value })}
                    style={{
                      width: '100%',
                      height: '32px',
                      border: '1px solid #ccc',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      padding: '0',
                    }}
                  />
                </div>
                <div style={{ flex: 1 }}>
                  <label style={{ 
                    display: 'block', 
                    fontSize: '12px', 
                    marginBottom: '6px',
                    fontWeight: '500',
                    color: '#333'
                  }}>
                    Border
                  </label>
                  <input
                    type="color"
                    value={state.local.containerBorderColor || '#dee2e6'}
                    onChange={(e) => handleLocalStyleChange({ containerBorderColor: e.target.value })}
                    style={{
                      width: '100%',
                      height: '32px',
                      border: '1px solid #ccc',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      padding: '0',
                    }}
                  />
                </div>
              </div>

              {/* Container Border Width */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Border Width: {state.local.containerBorderWidth || 2}px
                </label>
                <input
                  type="range"
                  min="0"
                  max="8"
                  step="0.5"
                  value={state.local.containerBorderWidth || 2}
                  onChange={(e) => handleLocalStyleChange({ containerBorderWidth: parseFloat(e.target.value) })}
                  style={{ 
                    width: '100%',
                    cursor: 'pointer',
                  }}
                />
              </div>

              {/* Container Border Radius */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Border Radius: {state.local.containerBorderRadius || 8}px
                </label>
                <input
                  type="range"
                  min="0"
                  max="20"
                  step="1"
                  value={state.local.containerBorderRadius || 8}
                  onChange={(e) => handleLocalStyleChange({ containerBorderRadius: parseInt(e.target.value) })}
                  style={{ 
                    width: '100%',
                    cursor: 'pointer',
                  }}
                />
              </div>

              {/* Container Shadow */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Shadow
                </label>
                <select
                  value={state.local.containerShadow || 'light'}
                  onChange={(e) => handleLocalStyleChange({ 
                    containerShadow: e.target.value as 'none' | 'light' | 'medium' | 'heavy' 
                  })}
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid #ccc',
                    borderRadius: '4px',
                    fontSize: '14px',
                    backgroundColor: 'white',
                    cursor: 'pointer',
                  }}
                >
                  <option value="none">None</option>
                  <option value="light">Light</option>
                  <option value="medium">Medium</option>
                  <option value="heavy">Heavy</option>
                </select>
              </div>

              {/* Container Opacity */}
              <div>
                <label style={{ 
                  display: 'block', 
                  fontSize: '12px', 
                  marginBottom: '6px',
                  fontWeight: '500',
                  color: '#333'
                }}>
                  Opacity: {Math.round((state.local.containerOpacity || 0.9) * 100)}%
                </label>
                <input
                  type="range"
                  min="0.1"
                  max="1"
                  step="0.05"
                  value={state.local.containerOpacity || 0.9}
                  onChange={(e) => handleLocalStyleChange({ containerOpacity: parseFloat(e.target.value) })}
                  style={{ 
                    width: '100%',
                    cursor: 'pointer',
                  }}
                />
                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  fontSize: '10px',
                  color: '#666',
                  marginTop: '2px'
                }}>
                  <span>10%</span>
                  <span>100%</span>
                </div>
              </div>
            </div>
          </CollapsibleSection>

          {/* Settings Persistence Status */}
          <div style={{
            padding: '8px',
            backgroundColor: '#e9ecef',
            borderRadius: '4px',
            border: '1px solid #dee2e6',
            marginTop: '8px',
            fontSize: '11px',
            color: '#666'
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <span>Settings Persistence</span>
              <span>
                {state.settingsStatus === 'saving' && 'ðŸ’¾ Saving...'}
                {state.settingsStatus === 'saved' && 'âœ“ Saved'}
                {state.settingsStatus === 'error' && 'âš  Error'}
                {state.settingsStatus === 'idle' && 'ðŸ’¤ Idle'}
              </span>
            </div>
            <div style={{ fontSize: '10px', color: '#888', marginTop: '2px' }}>
              All settings are automatically saved to browser localStorage
            </div>
          </div>

          {/* Real-time Preview */}
          <div style={{
            padding: '12px',
            backgroundColor: '#f8f9fa',
            borderRadius: '6px',
            border: '1px solid #e9ecef',
            marginTop: '8px'
          }}>
            <div style={{
              fontSize: '12px',
              color: '#666',
              marginBottom: '8px',
              fontWeight: '500'
            }}>
              Real-time Preview
            </div>
            <div style={{
              fontSize: '10px',
              color: '#888',
              marginBottom: '8px'
            }}>
              Changes are applied immediately with local state synchronization
            </div>
            
            {/* Mini preview elements */}
            <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
              {/* Sample Node */}
              <div
                style={{
                  padding: `${state.local.nodePadding || 8}px`,
                  backgroundColor: state.local.nodeBackgroundColor || '#ffffff',
                  border: `${state.local.nodeBorderWidth || 1}px solid ${state.local.nodeBorderColor || '#cccccc'}`,
                  borderRadius: `${state.local.nodeBorderRadius || 4}px`,
                  fontSize: `${Math.max((state.local.nodeFontSize || 12) - 2, 8)}px`,
                  fontWeight: state.local.nodeFontWeight || 'normal',
                  color: '#333',
                  minWidth: '40px',
                  textAlign: 'center'
                }}
              >
                Node
              </div>
              
              {/* Sample Edge */}
              <div
                style={{
                  width: '20px',
                  height: `${state.local.edgeWidth || 2}px`,
                  backgroundColor: state.local.edgeColor || '#1976d2',
                  borderStyle: state.local.edgeDashed ? 'dashed' : 'solid',
                  borderWidth: '0',
                  borderTopWidth: `${state.local.edgeWidth || 2}px`,
                  borderColor: state.local.edgeColor || '#1976d2',
                  animation: state.local.edgeAnimated ? 'pulse 2s infinite' : 'none',
                }}
              />
              
              {/* Sample Container */}
              <div
                style={{
                  padding: '6px 8px',
                  backgroundColor: state.local.containerBackgroundColor || '#f8f9fa',
                  border: `${state.local.containerBorderWidth || 2}px solid ${state.local.containerBorderColor || '#dee2e6'}`,
                  borderRadius: `${state.local.containerBorderRadius || 8}px`,
                  fontSize: '8px',
                  color: '#666',
                  opacity: state.local.containerOpacity || 0.9,
                  boxShadow: 
                    state.local.containerShadow === 'none' ? 'none' :
                    state.local.containerShadow === 'light' ? '0 1px 3px rgba(0,0,0,0.1)' :
                    state.local.containerShadow === 'medium' ? '0 2px 6px rgba(0,0,0,0.15)' :
                    '0 4px 12px rgba(0,0,0,0.2)'
                }}
              >
                Container
              </div>
            </div>
          </div>

          </div>
        </ErrorBoundary>
      </div>
    </div>
  );
};

// ============================================================================
// Error Boundary Component
// ============================================================================

interface ErrorBoundaryProps {
  children: React.ReactNode;
  onError?: (error: Error) => void;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('StyleTuner Error Boundary:', {
      error,
      errorInfo,
      timestamp: new Date().toISOString()
    });
    
    this.props.onError?.(error);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{
          padding: '20px',
          backgroundColor: '#f8d7da',
          border: '1px solid #f5c6cb',
          borderRadius: '4px',
          color: '#721c24',
          textAlign: 'center'
        }}>
          <h4 style={{ margin: '0 0 8px 0', fontSize: '14px' }}>
            StyleTuner Error
          </h4>
          <p style={{ margin: '0 0 12px 0', fontSize: '12px' }}>
            {this.state.error?.message || 'An unexpected error occurred'}
          </p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            style={{
              padding: '6px 12px',
              backgroundColor: '#721c24',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '12px'
            }}
          >
            Retry
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default StyleTuner;